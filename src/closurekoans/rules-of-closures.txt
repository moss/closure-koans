Lesson 1: Rules of closures
 0) An expression is done the moment you define it.
 1) A closure is something to do.
 \-- calling explicitly
 \-- calling implicitly
 2) A closure does nothing until you call it.
 3) A closure can return a value.
 \-- returning explicitly
 \-- returning implicitly
 4) A closure can take arguments.
 \-- explicit arguments
 \-- implicit argument
 \-- no implicit argument given
 5) A closure closes over its environment.

Lesson 2: Closing over state
 0) A closure closes over its environment.
 1) A closure can change state that it has captured.
 2) By returning a closure, a function can define a function.
 3) Closures resulting from different function calls are isolated from each other.
 4) You can use closures to define multiple similar functions.
 5) A closure can carry hidden state that it modifies over time.

Lesson 3: Closures in APIs
 0) A parameter lets you vary the data that a function works with.
 1) A closure lets you vary the operations that a function uses to do its work.
 2) Groovy syntax for Closure method arguments.
 3) Closures can describe transformations of data.
 4) Closures can be used to filter data.
 5) By taking closure arguments, a method can act as a new control structure.
 6) A closure can represent deferred work.
 7) A closure can represent work awaiting a context.

Lesson 4: Some Groovy-specific features
 0) Groovy does some stuff differently.
 1) You can add new methods to a class by setting closures on its metaClass.
 \- per-instance metaClasses
 2) The owner of a closure is the class where it was defined.
 \- If the closure was defined in another closure, the owner is that closure.
 3) The delegate of a closure defaults to being its owner.
 4) By setting the delegate, you can make new data available in the closure.
 5) A closure can implement a Java interface.